## 简介

一道Hard题目，在职场社区交流中发现曝光率很高，在微软面试中被面试者反馈被考过这道题。这题是平面接雨水的升级版，思路上平面版接雨水有些差异，主要思路有最小堆和广度优先搜索，从时间复杂度上最小堆解法要优于广度优先搜索，所以这里只介绍最小堆解法

### 题目描述

Given an m x n integer matrix heightMap representing the height of each unit cell in a 2D elevation map, return the volume of water it can trap after raining.

```
Input: heightMap = [[1,4,3,1,3,2],[3,2,1,3,2,4],[2,3,3,2,3,1]]
Output: 4
Explanation: After the rain, water is trapped between the blocks.
We have two small ponds 1 and 3 units trapped.
The total volume of water trapped is 4.

// Example 2:

Input: heightMap = [[3,3,3,3,3],[3,2,2,2,3],[3,2,1,2,3],[3,2,2,2,3],[3,3,3,3,3]]
Output: 10
```

### 思路
我们假设方块的索引为(i,j)，方块的高度为heightMap[i][j]，方块接水后的高度为water[i][j]则我们知道方块(i,j)的接水后的高度为：
water[i][j]=max(heightMap[i][j],min(water[i−1][j],water[i+1][j],water[i][j−1],water[i][j+1])), 方块(i,j)实际接水的
容量计算公式为water[i][j]−heightMap[i][j](两者的高度差)

1. 遍历heightMap，将每个位置的1维索引值和对应高度值放入最小堆;
2. 取出当前最小高度cur与索对ind，遍历上下左右四个邻居，如果当前邻居位置indNew没有访问，则将当前邻居位置indNew标记已访问，同时将当前邻居位置高度curNew与当前最小高度cur的较大值与indNew放入最小堆，用于下一圈的雨水高度差计算，如果curNew小于cur，说明邻居位置indNew与当前位置ind存在高度差可以用来接收雨水，能接收的雨水量为两者高度差;
3. 重复上面过程直到最小堆清空;

本题运用了木桶原理推导出方块接水后高度的动态规划递推公式，然后借助最小堆找到下一个方块节水后最小高度值，简化寻找最小值过程

### 解法

```C++
class Solution {
public:
	int trapRainWater(vector<vector<int>>& heightMap) {
		int r = heightMap.size();  // 行数
		int c = heightMap[0].size(); // 列数
		using pii = pair<int, int>; // {接水高度， 二维坐标压缩成一维后的值}
		priority_queue<pii, vector<pii>, greater<pii>> minHeap; // 记录接水后的高度最小值
		vector<vector<bool>> visited(r, vector<bool>(c, false)); // 标记某个位置是否被遍历过
		for (int i = 0; i < r; ++i) {
			for (int j = 0; j < c; ++j) {
				if (i == 0 || i == r - 1 || j == 0 || j == c - 1) {
					minHeap.push({ heightMap[i][j], i * c + j });
					visited[i][j] = true;
				}
			}
		}
		int res = 0; // 接收的雨水总量
		static constexpr int dirs[] = { -1, 0, 1, 0, -1 };
		while (minHeap.size()) {
			auto [cur, ind] = minHeap.top();
			minHeap.pop();
			for (int k = 0; k < 4; ++k) { // 对上下左右相邻位置进行遍历
				int nx = ind / c + dirs[k];
				int ny = ind % c + dirs[k + 1];
				if (nx >= 0 && nx < r && ny >= 0 && ny < c && !visited[nx][ny]) { // 邻居没有访问过
					if (heightMap[nx][ny] < cur) { // [nx,ny]位置的高度小于当前位置说明有高度差，可以接收雨水
						res += cur - heightMap[nx][ny]; // 接收的雨水量为高度差
					}
					visited[nx][ny] = true; // 将遍历过邻居标记，避免重复访问
					minHeap.push({ max(heightMap[nx][ny], cur), nx * c + ny }); // 将当前位置与邻居的高度较大值作为当前邻居的新高度重新放入最小堆中，用于下一圈高度差比较和雨水接收量计算
				}
			}
		}
		return res;
	}
};
```

### testcase验证

```C++
Solution s;
vector<vector<int>> heightMap = {{12, 13, 1, 12}, {13, 4, 13, 12}, {13, 8, 10, 12}, {12, 13, 12, 12}, {13, 13, 13, 13}} ;
cout<<s.trapRainWater(heightMap)<<endl;

// 4
```

```C++
Solution s;
vector<vector<int>> heightMap = {{3, 3, 3, 3, 3}, {3, 2, 2, 2, 3}, {3, 2, 1, 2, 3}, {3, 2, 2, 2, 3}, {3, 3, 3, 3, 3}} ;
cout << s.trapRainWater(heightMap) << endl;

// 10
```

